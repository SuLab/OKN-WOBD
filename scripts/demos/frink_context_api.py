#!/usr/bin/env python3
"""
Python API for accessing FRINK NL-to-SPARQL context data.

This module provides a programmatic interface for loading and querying
the context file generated by frink_context_builder.py.

Usage:
    from frink_context_api import FrinkContext

    # Load context
    ctx = FrinkContext.load("frink_context.json")

    # Get graph metadata
    ubergraph = ctx.get_graph("ubergraph")
    print(ubergraph["metadata"]["sparql_endpoint"])

    # Get endpoint URL
    endpoint = ctx.get_endpoint("spoke-okn")

    # Find graphs by domain
    biomedical = ctx.find_graphs_by_domain("biomedical")

    # Get prefixes for federated query
    prefixes = ctx.get_prefixes_for_graphs(["ubergraph", "nde"])

    # Build SERVICE clause
    clause = ctx.build_service_clause("ubergraph", "?x rdfs:label ?label .")

    # Get example queries
    examples = ctx.get_example_queries(federated=True)
"""

import json
from typing import Dict, List, Any, Optional, Set
from pathlib import Path
from dataclasses import dataclass


@dataclass
class ExampleQuery:
    """An example SPARQL query from the context."""
    name: str
    natural_language: str
    sparql: str
    notes: str = ""
    graph: Optional[str] = None
    graphs: Optional[List[str]] = None

    @property
    def is_federated(self) -> bool:
        return self.graphs is not None and len(self.graphs) > 1


class FrinkContext:
    """
    API for accessing FRINK NL-to-SPARQL context data.

    Provides methods for:
    - Loading and accessing graph metadata and schemas
    - Finding graphs by domain or capability
    - Building SPARQL prefixes and SERVICE clauses
    - Retrieving example queries

    Example:
        ctx = FrinkContext.load("frink_context.json")

        # Get ubergraph endpoint
        endpoint = ctx.get_endpoint("ubergraph")

        # Find biomedical graphs
        graphs = ctx.find_graphs_by_domain("biomedical")

        # Build prefixes for a federated query
        prefix_str = ctx.get_prefix_declarations(["ubergraph", "nde"])
    """

    def __init__(self, context_data: Dict[str, Any]):
        """
        Initialize with context data.

        Args:
            context_data: Loaded context dictionary
        """
        self._data = context_data
        self._graphs = context_data.get("knowledge_graphs", {})
        self._external = context_data.get("external_endpoints", {})
        self._common_prefixes = context_data.get("common_prefixes", {})
        self._examples = context_data.get("example_queries", {})
        self._patterns = context_data.get("federated_query_patterns", {})
        self._instructions = context_data.get("usage_instructions", {})

    @classmethod
    def load(cls, path: str | Path) -> "FrinkContext":
        """
        Load context from a JSON file.

        Args:
            path: Path to the context JSON file

        Returns:
            FrinkContext instance

        Raises:
            FileNotFoundError: If context file doesn't exist
            json.JSONDecodeError: If file is not valid JSON
        """
        path = Path(path)
        with open(path, "r", encoding="utf-8") as f:
            data = json.load(f)
        return cls(data)

    @classmethod
    def load_default(cls) -> "FrinkContext":
        """
        Load context from the default location (same directory as this file).

        Returns:
            FrinkContext instance
        """
        default_path = Path(__file__).parent / "frink_context.json"
        return cls.load(default_path)

    # =========================================================================
    # Basic Accessors
    # =========================================================================

    @property
    def version(self) -> str:
        """Context file version."""
        return self._data.get("version", "unknown")

    @property
    def generated_at(self) -> str:
        """When the context was generated."""
        return self._data.get("generated_at", "unknown")

    @property
    def registry_url(self) -> str:
        """URL of the FRINK registry."""
        return self._data.get("registry_url", "https://frink.renci.org/registry/")

    @property
    def federated_endpoint(self) -> str:
        """URL of the federated query endpoint."""
        return self._data.get("federated_endpoint", "https://frink.apps.renci.org/?query=")

    @property
    def graph_names(self) -> List[str]:
        """List of all graph shortnames."""
        return list(self._graphs.keys())

    @property
    def common_prefixes(self) -> Dict[str, str]:
        """Common prefixes shared across graphs."""
        return self._common_prefixes.copy()

    @property
    def external_endpoint_names(self) -> List[str]:
        """List of external endpoint names (wikidata, uniprot, etc.)."""
        return list(self._external.keys())

    # =========================================================================
    # External Endpoints (non-FRINK)
    # =========================================================================

    def get_external_endpoint(self, name: str) -> Optional[Dict[str, Any]]:
        """
        Get external endpoint data by name.

        Args:
            name: Endpoint name (e.g., "wikidata", "uniprot")

        Returns:
            Endpoint data dict or None if not found
        """
        return self._external.get(name)

    def get_external_sparql_url(self, name: str) -> Optional[str]:
        """
        Get SPARQL endpoint URL for an external endpoint.

        Args:
            name: Endpoint name

        Returns:
            SPARQL endpoint URL or None
        """
        endpoint = self._external.get(name)
        if endpoint:
            return endpoint.get("sparql_endpoint")
        return None

    def get_external_prefixes(self, name: str) -> Dict[str, str]:
        """
        Get prefixes for an external endpoint.

        Args:
            name: Endpoint name

        Returns:
            Dict of prefix name -> URI
        """
        endpoint = self._external.get(name)
        if endpoint:
            return endpoint.get("prefixes", {})
        return {}

    def get_external_query_patterns(self, name: str) -> List[str]:
        """
        Get query patterns for an external endpoint.

        Args:
            name: Endpoint name

        Returns:
            List of pattern strings
        """
        endpoint = self._external.get(name)
        if endpoint:
            return endpoint.get("query_patterns", [])
        return []

    # =========================================================================
    # Graph Access
    # =========================================================================

    def get_graph(self, shortname: str) -> Optional[Dict[str, Any]]:
        """
        Get complete data for a graph by shortname.

        Args:
            shortname: Graph shortname (e.g., "ubergraph")

        Returns:
            Graph data dict or None if not found
        """
        return self._graphs.get(shortname)

    def get_endpoint(self, shortname: str) -> Optional[str]:
        """
        Get SPARQL endpoint URL for a graph.

        Args:
            shortname: Graph shortname

        Returns:
            SPARQL endpoint URL or None if not found
        """
        graph = self._graphs.get(shortname)
        if graph:
            return graph.get("metadata", {}).get("sparql_endpoint")
        return None

    def get_metadata(self, shortname: str) -> Optional[Dict[str, Any]]:
        """
        Get metadata for a graph.

        Args:
            shortname: Graph shortname

        Returns:
            Metadata dict or None
        """
        graph = self._graphs.get(shortname)
        if graph:
            return graph.get("metadata")
        return None

    def get_schema(self, shortname: str) -> Optional[Dict[str, Any]]:
        """
        Get schema (classes and properties) for a graph.

        Args:
            shortname: Graph shortname

        Returns:
            Schema dict with 'classes' and 'properties' keys, or None
        """
        graph = self._graphs.get(shortname)
        if graph:
            return graph.get("schema")
        return None

    def get_classes(self, shortname: str) -> List[Dict[str, Any]]:
        """
        Get list of classes for a graph.

        Args:
            shortname: Graph shortname

        Returns:
            List of class dicts with uri, label, count
        """
        schema = self.get_schema(shortname)
        if schema:
            return schema.get("classes", [])
        return []

    def get_properties(self, shortname: str) -> List[Dict[str, Any]]:
        """
        Get list of properties for a graph.

        Args:
            shortname: Graph shortname

        Returns:
            List of property dicts with uri, label, usage_count
        """
        schema = self.get_schema(shortname)
        if schema:
            return schema.get("properties", [])
        return []

    def get_property_labels(self, shortname: str) -> List[str]:
        """
        Get list of property labels for a graph.

        Args:
            shortname: Graph shortname

        Returns:
            List of property label strings
        """
        return [p.get("label", "") for p in self.get_properties(shortname)]

    def get_schema_summary(self, shortname: str, max_properties: int = 20) -> str:
        """
        Get a brief text summary of a graph's schema.

        Args:
            shortname: Graph shortname
            max_properties: Maximum number of properties to include

        Returns:
            Text summary of schema
        """
        props = self.get_properties(shortname)
        prefixes = self.get_graph_prefixes(shortname)

        parts = []
        if props:
            prop_labels = [p.get("label", "") for p in props[:max_properties]]
            parts.append(f"Properties: {', '.join(prop_labels)}")
            if len(props) > max_properties:
                parts.append(f"  ... and {len(props) - max_properties} more")
        if prefixes:
            prefix_list = [f"{k}:" for k in list(prefixes.keys())[:10]]
            parts.append(f"Prefixes: {', '.join(prefix_list)}")

        return "\n".join(parts) if parts else "No schema data available"

    def get_graph_prefixes(self, shortname: str) -> Dict[str, str]:
        """
        Get graph-specific prefixes.

        Args:
            shortname: Graph shortname

        Returns:
            Dict of prefix name -> URI
        """
        graph = self._graphs.get(shortname)
        if graph:
            return graph.get("prefixes", {})
        return {}

    # =========================================================================
    # Graph Discovery
    # =========================================================================

    def find_graphs_by_domain(self, domain: str) -> List[str]:
        """
        Find graphs belonging to a domain.

        Args:
            domain: Domain name (e.g., "biomedical", "ontology", "geospatial")

        Returns:
            List of graph shortnames matching the domain
        """
        matches = []
        domain_lower = domain.lower()
        for shortname, graph in self._graphs.items():
            graph_domain = graph.get("metadata", {}).get("domain", "").lower()
            if domain_lower in graph_domain or graph_domain in domain_lower:
                matches.append(shortname)
        return matches

    def find_graphs_with_class(self, class_pattern: str) -> List[str]:
        """
        Find graphs containing a class matching a pattern.

        Args:
            class_pattern: Substring to match in class URI or label

        Returns:
            List of graph shortnames
        """
        pattern_lower = class_pattern.lower()
        matches = []
        for shortname, graph in self._graphs.items():
            classes = graph.get("schema", {}).get("classes", [])
            for cls in classes:
                if pattern_lower in cls.get("uri", "").lower() or \
                   pattern_lower in cls.get("label", "").lower():
                    matches.append(shortname)
                    break
        return matches

    def find_graphs_with_property(self, property_pattern: str) -> List[str]:
        """
        Find graphs containing a property matching a pattern.

        Args:
            property_pattern: Substring to match in property URI or label

        Returns:
            List of graph shortnames
        """
        pattern_lower = property_pattern.lower()
        matches = []
        for shortname, graph in self._graphs.items():
            properties = graph.get("schema", {}).get("properties", [])
            for prop in properties:
                if pattern_lower in prop.get("uri", "").lower() or \
                   pattern_lower in prop.get("label", "").lower():
                    matches.append(shortname)
                    break
        return matches

    def get_domains(self) -> List[str]:
        """
        Get list of all unique domains.

        Returns:
            Sorted list of domain names
        """
        domains = set()
        for graph in self._graphs.values():
            domain = graph.get("metadata", {}).get("domain")
            if domain:
                domains.add(domain)
        return sorted(domains)

    # =========================================================================
    # Prefix Handling
    # =========================================================================

    def get_prefixes_for_graphs(self, shortnames: List[str]) -> Dict[str, str]:
        """
        Get merged prefixes for multiple graphs.

        Combines common prefixes with graph-specific prefixes.

        Args:
            shortnames: List of graph shortnames

        Returns:
            Dict of prefix name -> URI
        """
        prefixes = self._common_prefixes.copy()
        for shortname in shortnames:
            graph_prefixes = self.get_graph_prefixes(shortname)
            prefixes.update(graph_prefixes)
        return prefixes

    def get_prefix_declarations(self, shortnames: Optional[List[str]] = None) -> str:
        """
        Generate SPARQL PREFIX declarations.

        Args:
            shortnames: List of graphs to include prefixes for (None = common only)

        Returns:
            SPARQL PREFIX block as string
        """
        if shortnames:
            prefixes = self.get_prefixes_for_graphs(shortnames)
        else:
            prefixes = self._common_prefixes

        lines = [f"PREFIX {name}: <{uri}>" for name, uri in sorted(prefixes.items())]
        return "\n".join(lines)

    # =========================================================================
    # Query Building Helpers
    # =========================================================================

    def build_service_clause(self, shortname: str, subquery: str, indent: int = 2) -> str:
        """
        Build a SPARQL SERVICE clause for a graph.

        Args:
            shortname: Graph shortname
            subquery: SPARQL pattern to wrap in SERVICE
            indent: Number of spaces to indent the subquery

        Returns:
            SERVICE clause string
        """
        endpoint = self.get_endpoint(shortname)
        if not endpoint:
            raise ValueError(f"Unknown graph: {shortname}")

        # Indent subquery lines
        indent_str = " " * indent
        indented = "\n".join(indent_str + line for line in subquery.strip().split("\n"))

        return f"SERVICE <{endpoint}> {{\n{indented}\n}}"

    def build_federated_query(
        self,
        graph_queries: Dict[str, str],
        select_vars: str = "*",
        limit: Optional[int] = None,
    ) -> str:
        """
        Build a complete federated SPARQL query.

        Args:
            graph_queries: Dict mapping shortname -> SPARQL WHERE pattern
            select_vars: Variables to SELECT (default: *)
            limit: Optional LIMIT clause

        Returns:
            Complete SPARQL query string
        """
        # Collect all prefixes
        prefixes = self.get_prefix_declarations(list(graph_queries.keys()))

        # Build SERVICE clauses
        services = []
        for shortname, pattern in graph_queries.items():
            services.append(self.build_service_clause(shortname, pattern))

        # Assemble query
        where_body = "\n\n  ".join(services)

        query = f"""{prefixes}

SELECT {select_vars}
WHERE {{
  {where_body}
}}"""

        if limit:
            query += f"\nLIMIT {limit}"

        return query

    # =========================================================================
    # Example Queries
    # =========================================================================

    def get_example_queries(
        self,
        graph: Optional[str] = None,
        federated: Optional[bool] = None,
    ) -> List[ExampleQuery]:
        """
        Get example queries, optionally filtered.

        Args:
            graph: Filter to examples for a specific graph
            federated: If True, only federated; if False, only single-graph

        Returns:
            List of ExampleQuery objects
        """
        results = []

        # Single-graph examples
        if federated is not True:
            for ex in self._examples.get("single_graph", []):
                if graph and ex.get("graph") != graph:
                    continue
                results.append(ExampleQuery(
                    name=ex.get("name", ""),
                    natural_language=ex.get("natural_language", ""),
                    sparql=ex.get("sparql", ""),
                    notes=ex.get("notes", ""),
                    graph=ex.get("graph"),
                ))

        # Federated examples
        if federated is not False:
            for ex in self._examples.get("federated", []):
                if graph and graph not in ex.get("graphs", []):
                    continue
                results.append(ExampleQuery(
                    name=ex.get("name", ""),
                    natural_language=ex.get("natural_language", ""),
                    sparql=ex.get("sparql", ""),
                    notes=ex.get("notes", ""),
                    graphs=ex.get("graphs"),
                ))

        return results

    def get_example_by_name(self, name: str) -> Optional[ExampleQuery]:
        """
        Get a specific example query by name.

        Args:
            name: Example name

        Returns:
            ExampleQuery or None
        """
        for ex in self.get_example_queries():
            if ex.name == name:
                return ex
        return None

    # =========================================================================
    # Federated Query Patterns
    # =========================================================================

    def get_compatible_graph_groups(self) -> Dict[str, Any]:
        """
        Get groups of graphs that work well together for federated queries.

        Returns:
            Dict of group name -> group info (graphs, description, join_strategy)
        """
        return self._patterns.get("compatible_graph_groups", {})

    def get_join_strategies(self) -> List[Dict[str, str]]:
        """
        Get strategies for joining data across graphs.

        Returns:
            List of join strategy dicts with name, description, example
        """
        return self._patterns.get("join_strategies", [])

    # =========================================================================
    # Usage Instructions
    # =========================================================================

    def get_llm_hints(self) -> List[str]:
        """
        Get hints for LLM-based query generation.

        Returns:
            List of hint strings
        """
        return self._instructions.get("llm_prompt_hints", [])

    def get_usage_instructions(self) -> Dict[str, str]:
        """
        Get all usage instructions.

        Returns:
            Dict with instruction categories
        """
        return self._instructions.copy()

    # =========================================================================
    # Summary and Export
    # =========================================================================

    def summary(self) -> str:
        """
        Generate a text summary of the context.

        Returns:
            Multi-line summary string
        """
        lines = [
            f"FRINK Context Summary",
            f"=" * 40,
            f"Version: {self.version}",
            f"Generated: {self.generated_at}",
            f"",
            f"Knowledge Graphs: {len(self._graphs)}",
        ]

        # Count by domain
        domain_counts: Dict[str, int] = {}
        for graph in self._graphs.values():
            domain = graph.get("metadata", {}).get("domain", "unknown")
            domain_counts[domain] = domain_counts.get(domain, 0) + 1

        lines.append("  By domain:")
        for domain, count in sorted(domain_counts.items()):
            lines.append(f"    - {domain}: {count}")

        # Schema stats
        total_classes = sum(
            len(g.get("schema", {}).get("classes", []))
            for g in self._graphs.values()
        )
        total_props = sum(
            len(g.get("schema", {}).get("properties", []))
            for g in self._graphs.values()
        )

        lines.extend([
            f"",
            f"Schema Coverage:",
            f"  Total classes: {total_classes}",
            f"  Total properties: {total_props}",
            f"",
            f"Example Queries:",
            f"  Single-graph: {len(self._examples.get('single_graph', []))}",
            f"  Federated: {len(self._examples.get('federated', []))}",
            f"",
            f"Common Prefixes: {len(self._common_prefixes)}",
        ])

        return "\n".join(lines)

    def to_dict(self) -> Dict[str, Any]:
        """
        Export full context as dictionary.

        Returns:
            Complete context data
        """
        return self._data.copy()


def demo():
    """Demonstrate the FrinkContext API."""
    import sys

    print("=" * 60)
    print("FRINK Context API Demo")
    print("=" * 60)

    # Try to load default context
    try:
        ctx = FrinkContext.load_default()
    except FileNotFoundError:
        print("\nNo context file found. Run frink_context_builder.py first:")
        print("  python frink_context_builder.py")
        sys.exit(1)

    print(f"\n{ctx.summary()}")

    print("\n" + "-" * 60)
    print("API Examples")
    print("-" * 60)

    # List graphs
    print(f"\nGraph names: {ctx.graph_names[:5]}...")

    # Get endpoint
    endpoint = ctx.get_endpoint("ubergraph")
    print(f"\nUbergraph endpoint: {endpoint}")

    # Find by domain
    ontology_graphs = ctx.find_graphs_by_domain("ontology")
    print(f"\nOntology graphs: {ontology_graphs}")

    # Get prefix declarations
    print("\nPrefix declarations for [ubergraph, nde]:")
    prefixes = ctx.get_prefix_declarations(["ubergraph", "nde"])
    print(prefixes[:200] + "...")

    # Build SERVICE clause
    print("\nExample SERVICE clause:")
    clause = ctx.build_service_clause("ubergraph", "?x rdfs:label ?label .")
    print(clause)

    # Get examples
    print("\nFederated example queries:")
    for ex in ctx.get_example_queries(federated=True):
        print(f"  - {ex.name}: {ex.natural_language[:50]}...")

    print("\n" + "=" * 60)
    print("Demo complete!")
    print("=" * 60)


if __name__ == "__main__":
    demo()
